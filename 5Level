#include<iostream>

using namespace std;

int main()
{
    cin.tie(NULL);
    ios::sync_with_stdio(false);
    int n, min, max;
    cin >> n;
    int* a = new int[n];
    for (int i = 0; i < n; i++)
        cin >> a[i];
    min = a[0];
    max = a[0];
    for (int i = 0; i < n; i++)
    {
        if (min > a[i])
            min = a[i];
        if (max < a[i])
            max = a[i];
    }
    cout << min << " " << max;

    return 0;
}
//cin.tie와 sync_with_stdio를 안썻더니 456ms가 떠서 두줄을 추가하여 120ms 까지 단축하였다.
//동적할당을 개념적으론 알고있지만 아직 사용법이 익숙하지 않아서 사용하지 않을려고 했는데 변수n개의 크기만큼 배열을 만들어 주기 위해서는 어쩔 수 없는건가???
-------------------------------------------------------------------------------------------------------
#include<iostream>

using namespace std;

int main()
{
    int n[9], max, cnt;                                                         int n[9], max=0, cnt;

    for (int i = 0; i < 9; i++)                                                 for (int i = 0; i < 9; i++)    
        cin >> n[i];                                                            {
    max = n[0];                                                                   cin >> n[i];
    for (int i = 0; i < 9; i++)                                                   if(max < n[i])                                      
    {                                                                             {
        if (max < n[i])                                                             max = n[i];
        {                                                                           cnt = i + 1;
            max = n[i];                                                           } 
            cnt = i + 1;                                                         }
        }                                                                       cout << max << "\n" << cnt;
    }
    cout << max << "\n" << cnt;

    return 0;
}
//왼쪽 코드가 처음에 작성한 코드인데 visual에서는 잘 작동되었고 디버깅도 해봣지만 오류없이 잘 되었는데 백준에서는 틀리다고 나왔다
//오른쪽 코드로 바꿔서 작성하였더니 통과하였다. max를 0으로 초기화해주는 차이 같은데 0으로 초기화하나 n[0]으로 초기화하나 무슨 차이인지 모르겠다.
------------------------------------------------------------------------------------------------------------------------
#include<iostream>

using namespace std;

int main()
{
    int a, b, c, mul, cnt[10] = { 0 }, n;
    cin >> a >> b >> c;
    mul = a * b * c;
    while (1)
    {
        n = mul % 10;
        if (n == 0)
            cnt[0] = cnt[0] + 1;
        else
            cnt[n] = cnt[n] + 1;
        mul = mul / 10;
        if (mul == 0)
            break;
    }
    for (int i = 0; i < 10; i++)
        cout << cnt[i] << "\n";
    return 0;
}
//c++ STL을 사용하면 곱한것을 문자열로 바꿔 하나씩 잘라서 나눌수 있는것을 알았지만 잘모르는 것을 이용해 쉽게 풀고싶지 않았다. 아직 초급단계이기 때문에
//아무것도 모르는 기본상태로 풀었다. 곱한것을 10으로 나누면서 나머지를 그 자리에맞는 배열 카운트를 하나씩 증겨시키면서 개수를 구했다.
------------------------------------------------------------------------------------------------------
#include<iostream>

using namespace std;

int main()
{
    int num[42] = { 0 };
    int a, cnt = 0;
    for (int i = 0; i < 10; i++)
    {
        cin >> a;
        num[a % 42]++;
    }
    for (int i = 0; i < 42; i++)
        if (num[i] != 0)
            cnt++;
    cout << cnt;
    return 0;
}
-----------------------------------------------------------------------------------------
#include<iostream>

using namespace std;

int main()
{
    cout << fixed;
    cout.precision(2);
    int n, m = 0;
    double avg, sum = 0;
    cin >> n;
    double* a = new double[n];
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for(int i=0;i<n;i++)
    {
        if (a[i] > m)
            m = a[i];      
    }
    for (int i = 0; i < n; i++)
    {
        a[i] = (double)a[i] / m * 100;
        sum += (double)a[i];
    }
    
    avg = (double)sum / n;
    cout << avg;
    return 0;
}
//이 문제도 마찬가지로 위에서 한거와 비슷하게 동적할당을 하여 배열의 크기를 잡아준다. 
//cout<<fixed , cout.precision(n)은 소수점 몇자리 까지 나타낼지 하기 위해 사용하는 것이다.
